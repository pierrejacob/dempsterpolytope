% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gibbs_sampler.R
\name{gibbs_sampler}
\alias{gibbs_sampler}
\title{Gibbs sampler for DS convex polytopes}
\usage{
gibbs_sampler(niterations, counts)
}
\arguments{
\item{niterations}{a number of iterations to perform;
each iteration is a full sweep of Gibbs updates for each category.
For help on choosing the number of iterations to perform,
see the function \code{\link{meeting_times}}.}

\item{counts}{a vector of non-negative integers containing
the count data; its length defines K, the number of categories. It can include zeros.}
}
\value{
A list with the following entries:
\itemize{
\item "etas": an array of dimension niterations x K x K.
For iteration 'iteration', etas\link{iteration,,} is a K x K matrix
representing a convex polytope.
The feasible set at that iteration, is the set of all vectors
theta such that, theta_l/theta_k < etas\link{iteration,k,l}
for all k,l in {1,...,K}.
\item "Us": a list of K arrays. For iteration 'iteration',
and category 'k' in {1,...,K}, if N_k = 0 then Us[\link{k}] is NA.
If N_k > 0 then Us[\link{k}]\link{iteration,,}
is a matrix with N_k rows, and K columns, representing the auxiliary variables
"U"'s generated at that iteration.
}
}
\description{
This is the main function of the package.
It runs the proposed Gibbs sampler
for a desired number of iterations, for a given vector of counts.
It generates a convex polytope at each iteration, in the form
of a matrix "eta".
Below the number of categories is denoted by K,
and corresponds to the length of the input vector 'counts'.
Each category k has count N_k, possibly equal to zero.
The zeros are removed from the counts when performing the Gibbs iterations,
and "added back" using \code{\link{extend_us}}.
}
\examples{
\dontrun{
gibbs_results <- gibbs_sampler(niterations = 5, counts = c(1,2,0,3))
gibbs_results$etas[5,,]
}
}
